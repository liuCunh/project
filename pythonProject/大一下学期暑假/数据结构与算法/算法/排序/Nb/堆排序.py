# 时间复杂度(nlongn)，空间复杂度O(1)
def sift(li, low, high):  # low:标识根节点，high:标识堆最后一个元素的位置
    i = low  # 最开始指向根节点，下标
    j = 2 * i + 1  # 指向左孩子(子节点中左边的那个)，下标
    tmp = li[low]  # 堆顶

    # 堆进行简单排序
    while j <= high:  # 左孩子没有到达最堆最后一个元素

        # 判断子节点中最大的节点
        if j + 1 <= high and li[j+1] > li[j]:  # 判断一:避免超过堆的最后一个元素，判断二: 右孩子大于左孩子
            j = j + 1  # 指向右孩子

        # 比较节点中的最大值并将其作为父节点
        if li[j] > tmp:  # 子节点大于父节点
            li[i] = li[j]  # 父、子节点的元素进行交换
            i = j  # 继承子节点下标
            j = 2 * i + 1  # 指向下一个子节点
        else:  # 堆根更大，把堆根放到左孩子的位置上来
            li[i] = tmp  # 把堆根放在左孩子的位置上
            break
    else:
        li[i] = tmp  # 堆根元素很小的情况下将会比较到堆最深层，导致无法在进行比较，将堆根直接放在叶子节点上


def heap_sort(li):
    n = len(li)

    # 建堆操作
    for i in range((n-2) // 2, -1, -1):  # (n-2)//2:堆最深层从左到右最后一个元素的下标，-1:列表第一个元素下标前一个下标，倒叙输出0
        # i表示建堆时调整部分的根的下标
        sift(li, i, n-1)  # 堆排序

    # 将树的根节点元素与树最深层从左到右最后一个叶子节点的元素进行交换
    for i in range(n-1, -1, -1):  # 从最后一个叶子节点开始到树根节点
        # i指向当前堆的最后一个元素
        li[0], li[i] = li[i], li[0]  # 树的根节点与最后一个叶子节点的元素交换
        sift(li, 0, i-1)  # 对树进行排序，将标识树最后一个叶子节点的high不断前移


import random
li = [i for i in range(10000)]
random.shuffle(li)
print(li)

heap_sort(li)
print(li)
